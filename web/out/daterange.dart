// Auto-generated from daterange.html.
// DO NOT EDIT.

library x_date_range;

import 'dart:html' as autogenerated;
import 'dart:svg' as autogenerated_svg;
import 'package:web_ui/web_ui.dart' as autogenerated;
import 'package:web_ui/observe/observable.dart' as __observe;
import 'dart:html';
import 'dart:async';
import 'dart:collection';
import 'package:web_ui/web_ui.dart';
import 'package:intl/date_symbol_data_local.dart';
import 'package:intl/date_symbols.dart';
import 'package:intl/intl_browser.dart';
import 'package:intl/intl.dart';



class DateRange extends WebComponent with Observable {
  /** Autogenerated from the template. */

  autogenerated.ScopedCssMapper _css;

  /** This field is deprecated, use getShadowRoot instead. */
  get _root => getShadowRoot("x-date-range");
  static final __html1 = new autogenerated.Element.html('<div id="dr_calendarsHolder">\n            <div class="dr_wrapper">\n              \n              <div class="dr_prev_container">\n                <button class="dr_button prev"></button>\n              </div>\n              <template></template>\n              <div class="dr_next_container">\n                <button class="dr_button next"></button>\n              </div>\n              <div class="dr_clearfix"></div>\n            </div>\n            <div class="dr_options-container">\n              <div class="dr_presets">\n                <span class="dr_label">Date range</span>\n                <select id="DrPresetOption" class="dr_select">\n                  <option value="custom">Custom</option>\n                  <option value="today">Today</option>\n                  <option value="yesterday">Yesterday</option>\n                  <option value="last-week">Last week</option>\n                  <option value="last-month">Last month</option>\n                </select>\n              </div>\n              <div class="dr_range_inputs">\n                <input id="rangeInputStart" type="text">\n                <span class="dr_pause">-</span>\n                <input id="rangeInputEnd" type="text">\n              </div>\n              <div class="dr_options_actions">\n                <button class="dr_button apply">Apply</button>\n                <a href="about:blank" target="_blank" class="dr_cancel">Cancel</a>\n              </div>\n            </div>\n          </div>'), __html2 = new autogenerated.Element.html('<div class="dr_calendar-container">\n                   <div class="dr_month-row">\n                    <span class="dr_month-txt"></span>\n                    <span class="dr_year-txt"></span>\n                  </div>\n                  <div class="dr_calendar-body">\n                    <table class="dr_table">\n                      <thead>\n                        <tr></tr>\n                      </thead>\n                      <tbody></tbody>\n                    </table>\n                  </div>\n                 </div>'), __html3 = new autogenerated.Element.html('<th class="dr_weekday"></th>'), __html4 = new autogenerated.TableRowElement(), __html5 = new autogenerated.Element.html('<td class="dr_day">\n                            <template></template>\n                          </td>'), __html6 = new autogenerated.Element.tag('template'), __html7 = new autogenerated.Element.html('<div class="dr_selectable"></div>'), __html8 = new autogenerated.Element.tag('template'), __html9 = new autogenerated.Element.html('<div class="dr_selectable_void"></div>'), __shadowTemplate = new autogenerated.DocumentFragment.html('''
        <div class="dr_input-value-wrapper">
          <div class="dr_wrapper">
            <span class="dr_value-display"></span>
          </div>
          
          <template></template>
        </div>
      ''');
  autogenerated.DivElement __e117;
  autogenerated.Element __e146;
  autogenerated.SpanElement __e116;
  autogenerated.Template __t;

  void created_autogenerated() {
    var __root = createShadowRoot("x-date-range");
    setScopedCss("x-date-range", new autogenerated.ScopedCssMapper({".next":"next",".dr_clearfix":"dr_clearfix",".dr_pause":"dr_pause",".dr_input-value-wrapper":"dr_input-value-wrapper",".dr_select":"dr_select",".dr_day":"dr_day",".dr_button":"dr_button",".dr_selectable_void":"dr_selectable_void",".dr_selectable":"dr_selectable",".dr_weekday":"dr_weekday",".dr_prev_container":"dr_prev_container",".dr_options_actions":"dr_options_actions",".dr_hidden":"dr_hidden",".dr_wrapper":"dr_wrapper",".dr_table":"dr_table",".dr_value-display":"dr_value-display",".disabled":"disabled",".dr_label":"dr_label",".apply":"apply",".dr_options-container":"dr_options-container",".prev":"prev",".dr_range_inputs":"dr_range_inputs",".dr_next_container":"dr_next_container",".dr_calendar-container":"dr_calendar-container",".dr_selected":"dr_selected",".dr_month-row":"dr_month-row","#dr_calendarsHolder":"dr_calendarsHolder","x-date-range":"[is=\"x-date-range\"]"}));
    _css = getScopedCss("x-date-range");
    __t = new autogenerated.Template(__root);
    if (__root is autogenerated.ShadowRoot) __root.applyAuthorStyles = true;
    __root.nodes.add(__shadowTemplate.clone(true));
    __e117 = __root.nodes[1].nodes[1];
    __e116 = __e117.nodes[1];
    var __binding115 = __t.contentBind(() => displayValue, false);
    __e116.nodes.add(__binding115);
    __t.listen(__e117.onClick, ($event) { show($event); });
    __e146 = __root.nodes[1].nodes[3];
    __t.conditional(__e146, () => showing, (__t) {
      var __e118, __e137, __e138, __e139, __e140, __e141, __e142, __e143, __e144, __e145;
      __e145 = __html1.clone(true);
      __e118 = __e145.nodes[1].nodes[1].nodes[1];
      __t.listen(__e118.onClick, ($event) { previousMonth(); });
      __e137 = __e145.nodes[1].nodes[3];
      __t.loop(__e137, () => calendarsList, ($list, $index, __t) {
        var calendar = $list[$index];
        var __e120, __e122, __e125, __e135, __e136;
        __e136 = __html2.clone(true);
        __e120 = __e136.nodes[1].nodes[1];
        var __binding119 = __t.contentBind(() => calendar.monthName, false);
        __e120.nodes.add(__binding119);
        __e122 = __e136.nodes[1].nodes[3];
        var __binding121 = __t.contentBind(() => calendar.year, false);
        __e122.nodes.add(__binding121);
        __e125 = __e136.nodes[3].nodes[1].nodes[1].nodes[1];
        __t.loopIterateAttr(__e125, () => weekdayTexts, ($list, $index, __t) {
          var weekday = $list[$index];
          var __e124;
          __e124 = __html3.clone(true);
          var __binding123 = __t.contentBind(() => weekday, false);
          __e124.nodes.add(__binding123);
        __t.addAll([new autogenerated.Text('\n                          '),
            __e124,
            new autogenerated.Text('\n                        ')]);
        });
        __e135 = __e136.nodes[3].nodes[1].nodes[3];
        __t.loopIterateAttr(__e135, () => calendar.dates, ($list, $index, __t) {
          var weekList = $list[$index];
          var __e134;
          __e134 = __html4.clone(true);
          __t.loopIterateAttr(__e134, () => weekList, ($list, $index, __t) {
            var day = $list[$index];
            var __e132, __e133;
            __e133 = __html5.clone(true);
            __e132 = __e133.nodes[1];
            __t.conditional(__e132, () => day != null, (__t) {
              var __e128, __e131;
              __e128 = __html6.clone(true);
              __t.conditional(__e128, () => calendar.isSelectable(day), (__t) {
                var __e127;
                __e127 = __html7.clone(true);
                var __binding126 = __t.contentBind(() => day, false);
                __e127.nodes.add(__binding126);
                __t.listen(__e127.onClick, ($event) { selectDay(calendar.year,calendar.month,day); });
                __t.bindClass(__e127, () => isSelected(calendar.year,calendar.month,day) ? ' dr_selected' : '', false);
              __t.addAll([new autogenerated.Text('\n                                '),
                  __e127,
                  new autogenerated.Text('\n                              ')]);
              });

              __e131 = __html8.clone(true);
              __t.conditional(__e131, () => !calendar.isSelectable(day), (__t) {
                var __e130;
                __e130 = __html9.clone(true);
                var __binding129 = __t.contentBind(() => day, false);
                __e130.nodes.add(__binding129);
              __t.addAll([new autogenerated.Text('\n                                '),
                  __e130,
                  new autogenerated.Text('\n                              ')]);
              });

            __t.addAll([new autogenerated.Text('\n                              '),
                __e128,
                new autogenerated.Text('\n                              '),
                __e131,
                new autogenerated.Text('\n                            ')]);
            });

          __t.addAll([new autogenerated.Text('\n                          '),
              __e133,
              new autogenerated.Text('\n                        ')]);
          });
        __t.addAll([new autogenerated.Text('\n                        '),
            __e134,
            new autogenerated.Text('\n                      ')]);
        });
      __t.addAll([new autogenerated.Text('\n                 '),
          __e136,
          new autogenerated.Text('\n              ')]);
      });
      __e138 = __e145.nodes[1].nodes[5].nodes[1];
      __t.listen(__e138.onClick, ($event) { nextMonth(); });
      __e139 = __e145.nodes[3].nodes[1].nodes[3];
      __t.listen(__e139.onChange, ($event) { presetRange($event); });
      __e142 = __e145.nodes[3].nodes[3];
      __e140 = __e142.nodes[1];
      __t.listen(__e140.onChange, ($event) { rangeInputsChange($event); });
      __t.listen(__e140.onFocus, ($event) { setAsCustomSelection(); });
      __t.listen(__e140.onInput, ($event) { startDateInput = __e140.value; });
      __t.oneWayBind(() => startDateInput, (e) { if (__e140.value != e) __e140.value = e; }, false, false);
      __e141 = __e142.nodes[5];
      __t.listen(__e141.onChange, ($event) { rangeInputsChange($event); });
      __t.listen(__e141.onFocus, ($event) { setAsCustomSelection(); });
      __t.listen(__e141.onInput, ($event) { endDateInput = __e141.value; });
      __t.oneWayBind(() => endDateInput, (e) { if (__e141.value != e) __e141.value = e; }, false, false);
      __t.bindClass(__e142, () => inputRangeCss, false);
      __e143 = __e145.nodes[3].nodes[5].nodes[1];
      __t.listen(__e143.onClick, ($event) { apply($event); });
      __e144 = __e145.nodes[3].nodes[5].nodes[3];
      __t.listen(__e144.onClick, ($event) { cancel($event); });
    __t.addAll([new autogenerated.Text('\n          \n          '),
        __e145,
        new autogenerated.Text('\n          ')]);
    });

    __t.create();
  }

  void inserted_autogenerated() {
    __t.insert();
  }

  void removed_autogenerated() {
    __t.remove();
    __t = __e117 = __e116 = __e146 = null;
  }

  /** Original code from the component. */

  DateTime __$selectionend;
  DateTime get selectionend {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'selectionend');
    }
    return __$selectionend;
  }
  set selectionend(DateTime value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'selectionend',
          __$selectionend, value);
    }
    __$selectionend = value;
  }
  DateTime __$selectionstart;
  DateTime get selectionstart {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'selectionstart');
    }
    return __$selectionstart;
  }
  set selectionstart(DateTime value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'selectionstart',
          __$selectionstart, value);
    }
    __$selectionstart = value;
  }
  
  
  bool __$initialized = false;
  bool get initialized {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'initialized');
    }
    return __$initialized;
  }
  set initialized(bool value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'initialized',
          __$initialized, value);
    }
    __$initialized = value;
  }
  bool __$showing = false;
  bool get showing {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'showing');
    }
    return __$showing;
  }
  set showing(bool value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'showing',
          __$showing, value);
    }
    __$showing = value;
  }
  ///Value to be displayed in display
  String get displayValue {
    if(selectionstart == null){
      //Must have selection start
      return "Select date range";
    }
    String start = _dateFormat.format(selectionstart);
    String end;
    if(selectionend == null){
      end = start;
    } else {
      end = _dateFormat.format(selectionend);
    }
    return "$start - $end";
  }
  
  DateFormat __$_dateFormat = new DateFormat.yMd();
  DateFormat get _dateFormat {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, '_dateFormat');
    }
    return __$_dateFormat;
  }
  set _dateFormat(DateFormat value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, '_dateFormat',
          __$_dateFormat, value);
    }
    __$_dateFormat = value;
  }
  String __$_locale;
  String get _locale {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, '_locale');
    }
    return __$_locale;
  }
  set _locale(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, '_locale',
          __$_locale, value);
    }
    __$_locale = value;
  }
  String get locale => _locale;
  set locale(String l){
    _locale = l;
    initializeDateFormatting(_locale, null)
      .then((_) => _initializeTexts(new DateFormat.E(l).dateSymbols))
      .then((_) => _dateFormat = new DateFormat.yMd(l));
  }
  
  int firstDayOfWeek;
  static final __changes = new __observe.Observable();

  static List<String> __$monthTexts = toObservable([]);
  static List<String> get monthTexts {
    if (__observe.observeReads) {
      __observe.notifyRead(__changes, __observe.ChangeRecord.FIELD, 'monthTexts');
    }
    return __$monthTexts;
  }
  static set monthTexts(List<String> value) {
    if (__observe.hasObservers(__changes)) {
      __observe.notifyChange(__changes, __observe.ChangeRecord.FIELD, 'monthTexts',
          __$monthTexts, value);
    }
    __$monthTexts = value;
  }
  static List<String> __$weekdayTexts = toObservable([]);
  static List<String> get weekdayTexts {
    if (__observe.observeReads) {
      __observe.notifyRead(__changes, __observe.ChangeRecord.FIELD, 'weekdayTexts');
    }
    return __$weekdayTexts;
  }
  static set weekdayTexts(List<String> value) {
    if (__observe.hasObservers(__changes)) {
      __observe.notifyChange(__changes, __observe.ChangeRecord.FIELD, 'weekdayTexts',
          __$weekdayTexts, value);
    }
    __$weekdayTexts = value;
  }
  set format(String f) => new DateFormat(f,locale);
  
  DateTime __$currentSelectedStart;
  DateTime get currentSelectedStart {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'currentSelectedStart');
    }
    return __$currentSelectedStart;
  }
  set currentSelectedStart(DateTime value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'currentSelectedStart',
          __$currentSelectedStart, value);
    }
    __$currentSelectedStart = value;
  }
  ///String value for selected date start
  String _startDateInput;
  /// Fetter for selected date start.
  /// If [_startDateInput] is null, then [currentSelectedStart] will be taken to format date.
  String get startDateInput => _startDateInput == null ? currentSelectedStart == null ? '' : _dateFormat.format(currentSelectedStart) : _startDateInput;
  DateTime __$currentSelectedEnd;
  DateTime get currentSelectedEnd {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'currentSelectedEnd');
    }
    return __$currentSelectedEnd;
  }
  set currentSelectedEnd(DateTime value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'currentSelectedEnd',
          __$currentSelectedEnd, value);
    }
    __$currentSelectedEnd = value;
  }
  String __$_endDateInput;
  String get _endDateInput {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, '_endDateInput');
    }
    return __$_endDateInput;
  }
  set _endDateInput(String value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, '_endDateInput',
          __$_endDateInput, value);
    }
    __$_endDateInput = value;
  }
  @observable String get endDateInput => _endDateInput == null ? currentSelectedEnd == null ? '' : _dateFormat.format(currentSelectedEnd) : _endDateInput;
  
  DateTime __$calendarStartDate = new DateTime.now();
  DateTime get calendarStartDate {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'calendarStartDate');
    }
    return __$calendarStartDate;
  }
  set calendarStartDate(DateTime value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'calendarStartDate',
          __$calendarStartDate, value);
    }
    __$calendarStartDate = value;
  }
  bool __$isCustomSelection = true;
  bool get isCustomSelection {
    if (__observe.observeReads) {
      __observe.notifyRead(this, __observe.ChangeRecord.FIELD, 'isCustomSelection');
    }
    return __$isCustomSelection;
  }
  set isCustomSelection(bool value) {
    if (__observe.hasObservers(this)) {
      __observe.notifyChange(this, __observe.ChangeRecord.FIELD, 'isCustomSelection',
          __$isCustomSelection, value);
    }
    __$isCustomSelection = value;
  }
  String get inputRangeCss => isCustomSelection ? '' : ' disabled';
  
  set startDateInput(String v){
    try{
      DateTime _try = _dateFormat.parse(v);
      
      if(limitright != null){
        DateTime compare = new DateTime(limitright.year,limitright.month, limitright.day);
        if(_try.isAfter(compare)){
          currentSelectedStart = compare;
          _startDateInput = _dateFormat.format(compare);
          return;
        }
      }
      if(limitleft != null){
        DateTime compare = new DateTime(limitleft.year, limitleft.month, limitleft.day);
        if(_try.isBefore(compare)){
          currentSelectedStart = compare;
          _startDateInput = _dateFormat.format(compare);
          return;
        }
      }
      
      
      currentSelectedStart = _try;
      _startDateInput = v;
      calendarStartDate = new DateTime(currentSelectedStart.year, currentSelectedStart.month+2,currentSelectedStart.day);
    }catch(e){
      print('Formated string: $v, locale: $locale');
      print(e);
    }
  }
  set endDateInput(String v){
    try{
      DateTime _try = _dateFormat.parse(v);
      if(limitright != null){
        DateTime compare = new DateTime(limitright.year,limitright.month, limitright.day);
        if(_try.isAfter(compare)){
          currentSelectedEnd = compare;
          _endDateInput = _dateFormat.format(compare);
          return;
        }
      }
      if(limitleft != null){
        DateTime compare = new DateTime(limitleft.year, limitleft.month, limitleft.day);
        if(_try.isBefore(compare)){
          currentSelectedEnd = compare;
          _endDateInput = _dateFormat.format(compare);
          return;
        }
      }
      currentSelectedEnd = _try;
      _endDateInput = v;
      //
      calendarStartDate = currentSelectedEnd;
    }catch(e){
      print('Formated string: $v, locale: $locale');
      print(e);
    }
  }
  
  /// Limit selector to dates before [limitright] date (exclusive).
  DateTime limitright;
  /// Limit selector to dates after [limitleft] date (exclusive).
  DateTime limitleft;
  
  int calendars = 3;
  @observable List<AppCalendar> get  calendarsList => _calendarsData();
  
  
  List<AppCalendar> _calendarsData(){
    if(!initialized) return [];
    
    List<AppCalendar> result = [];
    
    if(calendars > 3){
      calendars = 3;
    }
    
    
    int m = calendarStartDate.month;
    int y = calendarStartDate.year;
    
    m -= (calendars-1);
    if(m < 1){ //months are [1-12] based
      m = 12 + m; //m is only 0 to -11
      y--;
    }
    DateTime startDate = new DateTime(y, m, 1);
    
    for(int i=0; i<calendars; i++){
      int y = startDate.year;
      int m = startDate.month;
      m += i;
      if(m==13){
        m = 1;
        y++;
      }
      DateTime _date = new DateTime(y, m, 1);
      AppCalendar cal = _generateCalendar(_date);
      cal.calendarNo = i;
      result.add(cal);
    }
    
    return result;
  }
  
  AppCalendar _generateCalendar(DateTime date){
    
    AppCalendar calendar = new AppCalendar();
    List calendarList = [];
    
    DateTime first = new DateTime(date.year,date.month,1);
    DateTime last = new DateTime(date.year,date.month+1,1).subtract(new Duration(days:1));
     
    List<int> weekList = [null,null,null,null,null,null,null];
    int pos = first.weekday - firstDayOfWeek;
    if(pos >= 7)
      pos -= 7;
    if(pos < 0)
      pos += 7;
    for(int i=1; i<=last.day; i++){
      weekList[pos] = i;
      pos++;
      if(pos >= 7){
        calendarList.add(weekList);
        weekList = [null,null,null,null,null,null,null];
        pos = 0;
      }
    }
    if(pos > 0){
      calendarList.add(weekList);
    }
    
    calendar.dates = calendarList;
    calendar.monthName = monthTexts[date.month-1];
    calendar.year = date.year;
    
    calendar.month = date.month;
    if(limitleft != null){
      if(date.year <= limitleft.year && date.month <= limitleft.month){
        calendar.limitLeft = limitleft;
      }
    }
    if(limitright != null){
      bool setLimit = false;
      if(date.year > limitright.year){
        setLimit = true;
      } else if(date.year == limitright.year){
        if(date.month >= limitright.month){
          setLimit = true;
        }
      }
      if(setLimit){
        calendar.limitRight = limitright;
      }
    }
    if(limitleft != null){
      bool setLimit = false;
      if(date.year < limitleft.year){
        setLimit = true;
      } else if(date.year == limitleft.year){
        if(date.month <= limitleft.month){
          setLimit = true;
        }
      }
      if(setLimit){
        calendar.limitLeft = limitleft;
      }
    }
    return calendar;
  }
  
  void created(){
    currentSelectedStart = _getNow();
    currentSelectedEnd = currentSelectedStart;
    
    findSystemLocale()
      .then((_) => initializeDateFormatting(Intl.systemLocale, null))
      .then((_) => _dateFormat = new DateFormat.yMd(Intl.systemLocale))
      .then((_) => _initializeTexts(new DateFormat.E().dateSymbols));
  }
  
  void inserted(){
    if(selectionstart != null){
      currentSelectedStart = new DateTime(selectionstart.year, selectionstart.month, selectionstart.day);
      if(selectionend != null){
        currentSelectedEnd = new DateTime(selectionend.year, selectionend.month, selectionend.day);;
      } else {
        currentSelectedEnd = selectionstart;
      }
    }
  }
  
  Future _initializeTexts(DateSymbols ds){
    //print("Initialize text layer: $ds");
    firstDayOfWeek = ds.FIRSTDAYOFWEEK;
    //print("The first day of week is: $firstDayOfWeek");
    weekdayTexts.clear();
    for(int i=1; i<=7; i++){
      int k = firstDayOfWeek+i;
      if(k>=7)
        k = k - 7;
      weekdayTexts.add(ds.NARROWWEEKDAYS[k]);
    }
    monthTexts = ds.STANDALONESHORTMONTHS;
    initialized = true;
    return new Future.value();
  }
  
  void previousMonth(){
    calendarStartDate = new DateTime(calendarStartDate.year, calendarStartDate.month-1, calendarStartDate.day);
  }
  
  void nextMonth(){
    calendarStartDate = new DateTime(calendarStartDate.year, calendarStartDate.month+1, calendarStartDate.day);
  }
  
  bool firstDaySelected = false;
  void selectDay(int year, int month, int day){
    DateTime d = new DateTime(year, month, day);
    setAsCustomSelection();
    
    if(firstDaySelected){
      // If new selection is earlier than [currentSelectedStart] then replace the dates.
      if(d.isBefore(currentSelectedStart)){
        currentSelectedStart = d;
        currentSelectedEnd = d;
        return;
      }
      
      currentSelectedEnd = d;
      firstDaySelected = false;
    } else {
      // select both start and end range as the same date.
      currentSelectedEnd = d;
      currentSelectedStart = d;
      firstDaySelected = true;
    }
  }
  
  bool isSelected(int year, int month, int day){
    DateTime current = new DateTime(year, month, day);
    if(currentSelectedStart == null){
      return false;
    }
    
    // Need to copy object or it can contain hours, minutes and seconds which cause vary results
    DateTime compare = new DateTime(currentSelectedStart.year,currentSelectedStart.month, currentSelectedStart.day);
    
    
    if(current.isAtSameMomentAs(compare)){
      return true;
    }
    
    if(current.isAfter(compare)){
      //check left bound
      if(currentSelectedEnd == null){
        return false;
      }
      DateTime compareEnd = new DateTime(currentSelectedEnd.year,currentSelectedEnd.month, currentSelectedEnd.day);
      if(current.isBefore(compareEnd) || current.isAtSameMomentAs(compareEnd)){
        return true;
      }
    }
    return false;
  }
  /// Set current selection as a result
  void apply(Event e){
    selectionstart = currentSelectedStart;
    selectionend = currentSelectedEnd;
    showing = false;
    
    
    
    Event ce = new Event.eventType('HTMLEvents','change');
    host.dispatchEvent(ce);
  }
  /// Cancel dialog
  void cancel(Event e){
    e.preventDefault();
    showing = false;
  }
  
  void show(Event e){
    e.preventDefault();
    showing = true;
  }
  
  void rangeInputsChange(Event e){
    e.preventDefault();
    e.stopPropagation();
  }
  
  void presetRange(Event e){
    e.preventDefault();
    e.stopPropagation();
    SelectElement target = e.target;
    List<OptionElement> items = target.selectedOptions;
    if(items.length == 0) return;
    OptionElement item = items.first;
    switch(item.value){
      case 'today': 
        currentSelectedStart = _getNow();
        currentSelectedEnd = currentSelectedStart;
        isCustomSelection = false;
        firstDaySelected = false;
      break;
      case 'yesterday': 
        currentSelectedStart = _getNow().subtract(new Duration(days:1));
        currentSelectedEnd = currentSelectedStart;
        isCustomSelection = false;
        firstDaySelected = false;
        break;
      case 'last-week':
        DateTime helper = _getNow();
        currentSelectedStart = helper.subtract(new Duration(days: (7 + helper.weekday))); //remove 7 days and day of the week number
        currentSelectedEnd = helper.subtract(new Duration(days: (1 + helper.weekday))); // remove day of the week and one day
        isCustomSelection = false;
        firstDaySelected = false;
        break;
      case 'last-month': 
        DateTime helper = _getNow();
        currentSelectedStart = new DateTime(helper.year,helper.month-1,1);
        currentSelectedEnd = new DateTime(helper.year,helper.month,1).subtract(new Duration(days:1));
        isCustomSelection = false;
        firstDaySelected = false;
        break;
      case 'custom': 
        //nothing
        isCustomSelection = true;
        firstDaySelected = false;
        break;
    }
  }
  
  void setAsCustomSelection(){
    isCustomSelection = true;
    Element el = query('#DrPresetOption');
    if(el == null) return;
    (el as SelectElement).selectedIndex = 0;
  }
  
  
  /// Get current day [DateTime] object without hours, minutes, seconds and so on. 
  DateTime _getNow(){
    DateTime helper = new DateTime.now();
    return new DateTime(helper.year,helper.month,helper.day);
  }
  
}


class AppCalendar {
  ///Debug.
  int calendarNo;
  List dates;
  String monthName;
  int year;
  int month;
  bool get hasLimit => limitRight != null || limitLeft != null;
  ///Right limit for date range (limit for dates after this day)
  DateTime limitRight;
  ///Left limit for date range (limit for dates before this day)
  DateTime limitLeft;
  
  /// Return true if day can be selected.
  bool isSelectable(int day){
    if(!hasLimit) return true;
    //is limited right (the day is after limit)
    if(limitRight != null){
      return !new DateTime(year, month, day).isAfter(limitRight);
    }
    //is limited left (the day is before limit)
    if(limitLeft != null){
      return !new DateTime(year, month, day).isBefore(limitLeft);
    }
    return true;
  }
}
//# sourceMappingURL=daterange.dart.map